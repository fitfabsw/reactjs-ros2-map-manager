const express = require("express");
const multer = require("multer");
const sharp = require("sharp");
const path = require("path");
const cors = require("cors");
const fs = require("fs").promises;
const { exec } = require("child_process");
const util = require("util");
const execPromise = util.promisify(exec);
const yaml = require("js-yaml"); // 需要安裝: npm install js-yaml

const app = express();
app.use(cors());
app.use(express.json());

let compressedImageBuffer = null;
const MYPATH = process.env.MYPATH || "/home/zealzel/fitrobot_db";
console.log("MYPATH:", MYPATH);

// 創建一個目錄來存儲轉換後的圖片
const CONVERTED_PATH = path.join(__dirname, "converted");
fs.mkdir(CONVERTED_PATH).catch(() => {}); // 如果目錄已存在則忽略錯誤

app.get("/files", async (req, res) => {
  const dirPath = req.query.path || MYPATH;
  console.log("Getting files from directory:", dirPath);

  try {
    const files = await fs.readdir(dirPath);
    const fileStats = await Promise.all(
      files.map(async (file) => {
        const fullPath = path.join(dirPath, file);
        const stats = await fs.stat(fullPath);
        return {
          name: file,
          path: fullPath,
          size: stats.size,
          modifiedTime: stats.mtime,
          isDirectory: stats.isDirectory(),
        };
      }),
    );

    if (dirPath !== MYPATH) {
      fileStats.unshift({
        name: "..",
        path: path.dirname(dirPath),
        isDirectory: true,
      });
    }

    res.json({
      currentPath: dirPath,
      files: fileStats,
    });
  } catch (error) {
    console.error("Error reading directory:", error);
    res.status(500).json({ error: "Failed to read directory" });
  }
});

app.get("/file", async (req, res) => {
  const filePath = req.query.path;
  if (!filePath) {
    return res.status(400).json({ error: "File path is required" });
  }

  try {
    const buffer = await fs.readFile(filePath);
    if (filePath.toLowerCase().endsWith(".pgm")) {
      res.set("Content-Type", "application/octet-stream");
    } else {
      const contentType =
        path.extname(filePath).toLowerCase() === ".png"
          ? "image/png"
          : "image/jpeg";
      res.set("Content-Type", contentType);
    }
    res.send(buffer);
  } catch (error) {
    console.error("Error reading file:", error);
    res.status(500).json({ error: "Failed to read file" });
  }
});

// 使用 ImageMagick 轉換 PGM 到 PNG
async function convertPgmToPng(inputPath, outputPath) {
  try {
    const { stdout, stderr } = await execPromise(
      `convert "${inputPath}" "${outputPath}"`,
    );
    if (stderr) {
      console.error("ImageMagick stderr:", stderr);
    }
    if (stdout) {
      console.log("ImageMagick stdout:", stdout);
    }
  } catch (error) {
    console.error("ImageMagick error:", error);
    throw new Error(`ImageMagick conversion failed: ${error.message}`);
  }
}

// 讀取 YAML 文件
async function readYamlFile(filePath) {
  try {
    const yamlContent = await fs.readFile(filePath, "utf8");
    return yaml.load(yamlContent);
  } catch (error) {
    console.error("Error reading YAML file:", error);
    return null;
  }
}

app.post("/convert-pgm", async (req, res) => {
  try {
    const { filePath } = req.body;
    if (!filePath) {
      throw new Error("File path is required");
    }

    if (!filePath.toLowerCase().endsWith(".pgm")) {
      throw new Error("Only PGM files are supported");
    }

    // 讀取 YAML 文件
    const yamlPath = filePath.replace(".pgm", ".yaml");
    const yamlData = await readYamlFile(yamlPath);
    console.log("YAML data:", yamlData);
    console.log("yamlPath:", yamlPath);

    // 生成輸出文件路徑
    const outputFileName = `${path.basename(filePath, ".pgm")}.png`;
    const outputPath = path.join(CONVERTED_PATH, outputFileName);
    console.log("Converting PGM file:", filePath);
    console.log("Output path:", outputPath);

    // 使用 ImageMagick 進行轉換
    await convertPgmToPng(filePath, outputPath);
    console.log("Conversion successful");

    // 獲取圖片元數據
    const metadata = await sharp(outputPath).metadata();
    console.log("Original image metadata:", metadata);

    // 調整圖片大小
    const MAX_DIMENSION = 800;
    let width = metadata.width;
    let height = metadata.height;
    if (width > height && width > MAX_DIMENSION) {
      height = Math.round((height * MAX_DIMENSION) / width);
      width = MAX_DIMENSION;
    } else if (height > MAX_DIMENSION) {
      width = Math.round((width * MAX_DIMENSION) / height);
      height = MAX_DIMENSION;
    }
    console.log(`Resizing to: ${width}x${height}`);

    compressedImageBuffer = await sharp(outputPath)
      .resize(width, height, {
        fit: "inside",
        withoutEnlargement: true,
      })
      .toBuffer();

    console.log("AAA");
    // 準備響應數據
    const responseData = {
      image: compressedImageBuffer.toString("base64"),
      metadata: {
        mapWidth: metadata.width,
        mapHeight: metadata.height,
        resolution: yamlData?.resolution,
        origin: yamlData?.origin,
      },
    };

    console.log("BBB");
    // 發送響應
    res.json(responseData);
  } catch (error) {
    console.error("Conversion error:", error);
    res.status(500).json({
      error: "Image conversion failed",
      details: error.message,
    });
  }
});

app.post("/rotate", async (req, res) => {
  try {
    if (!compressedImageBuffer) {
      return res.status(400).json({ error: "No image has been uploaded yet" });
    }

    const angle = parseInt(req.body.angle) || 0;
    console.log("Rotating image by angle:", angle);

    const rotatedBuffer = await sharp(compressedImageBuffer)
      .rotate(angle, {
        background: { r: 205, g: 205, b: 205, alpha: 1.0 },
      })
      .toBuffer();

    res.set("Content-Type", "image/png");
    res.send(rotatedBuffer);
  } catch (error) {
    console.error("Rotation error:", error);
    res.status(500).json({ error: "Image rotation failed" });
  }
});

app.listen(5000, () => {
  console.log("Server is running on port 5000");
});
